<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8" />
		<title>WuQio Index</title>
		<link rel="stylesheet" type="text/css" href="css/demo.css">
		<link href="img/favicon.ico" rel="shortcut icon">
		<script src="js/jquery.min.js"></script>
	</head>
	<body>
		<div class="wallpaper">
			<div class="time"></div>
		</div>
		<div class="container">
			<header>
				A Shop of Postcards
			</header>
			<div class="container">
				<div class="side-link">
					<div class="logo">
						<a href="https://github.com/wuqio" target="_blank">
							<svg id="i-github" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64" width="24" height="24">
	    						<path stroke-width="0" fill="currentColor" d="M32 0 C14 0 0 14 0 32 0 53 19 62 22 62 24 62 24 61 24 60 L24 55 C17 57 14 53 13 50 13 50 13 49 11 47 10 46 6 44 10 44 13 44 15 48 15 48 18 52 22 51 24 50 24 48 26 46 26 46 18 45 12 42 12 31 12 27 13 24 15 22 15 22 13 18 15 13 15 13 20 13 24 17 27 15 37 15 40 17 44 13 49 13 49 13 51 20 49 22 49 22 51 24 52 27 52 31 52 42 45 45 38 46 39 47 40 49 40 52 L40 60 C40 61 40 62 42 62 45 62 64 53 64 32 64 14 50 0 32 0 Z" />
							</svg>
						</a>
					</div>
					<div class="logo">
						<a href="https://twitter.com/wuqiooo" target="_blank">
							<svg id="i-twitter" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64" width="24" height="24">
							    <path stroke-width="0" fill="currentColor" d="M60 16 L54 17 L58 12 L51 14 C42 4 28 15 32 24 C16 24 8 12 8 12 C8 12 2 21 12 28 L6 26 C6 32 10 36 17 38 L10 38 C14 46 21 46 21 46 C21 46 15 51 4 51 C37 67 57 37 54 21 Z" />
							</svg>
						</a>
					</div>
					<div class="logo">
						<a href="http://101.132.124.124" target="_blank">
							<svg id="i-eye" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" width="24" height="24" fill="none" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2">
							    <circle cx="17" cy="15" r="1" />
							    <circle cx="16" cy="16" r="6" />
							    <path d="M2 16 C2 16 7 6 16 6 25 6 30 16 30 16 30 16 25 26 16 26 7 26 2 16 2 16 Z" />
							</svg>
						</a>
					</div>
					<div class="logo up">
						<a href="####">
							<svg class="i-caret-top" viewBox="0 0 32 32" width="24" height="24" fill="none" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2">
	            				<path d="M30 22 L16 6 2 22 Z"></path>
	        				</svg>
						</a>
					</div>
					<div class="logo down">
						<a href="####">
							<svg id="i-caret-bottom" viewBox="0 0 32 32" width="24" height="24" fill="none" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2">
							    <path d="M30 10 L16 26 2 10 Z" />
							</svg>
						</a>
					</div>
				</div>
				<div class="grid-wrap">
					<div class="grid">
						<div class="figure card1">
							<h1>Deformation Transfer</h1>
							<img src="img/1.jpg" alt="1.jpg"/>
						</div>
						<div class="figure card2">
							<img src="img/5.jpg" alt="img05"/>
							<h1>Apache Zeppelin</h1>
						</div>
						<div class="figure card1">
							<h1>Zeppelin的搭建</h1>
							<img src="img/8.jpg" alt="img08"/>
						</div>
						<div class="figure card2">
							<img src="img/2.jpg" alt="img02"/>
							<h1>Zeppelin常见问题</h1>
						</div>
						<div class="figure card1">
							<h1>Python编码问题</h1>
							<img src="img/4.jpg" alt="img04"/>
						</div>
						<div class="figure card2">
							<img src="img/3.jpg" alt="img03"/>
							<h1>FFFFFF</h1>
						</div>
						<div class="figure card1">
							<h1>GGGGGG</h1>
							<img src="img/9.jpg" alt="img09"/>
						</div>
						<div class="figure card2">
							<img src="img/6.jpg" alt="img06"/>
							<h1>HHHHHH</h1>
						</div>
						<div class="figure card1">
							<h1>IIIIII</h1>
							<img src="img/7.jpg" alt="img07"/>
						</div>
					</div>
				</div>
				<div class="content">
					<div class="text-wrap">
						<div class="close-content">
							&times;
						</div>
						<div class="text">
							<h1>Deformation Transfer</h1>
							<p>之前有机会接触到一篇关于动画模型动作迁移的实现论文，这篇论文被引用很多次，其中的算法使用到了大量线性代数中矩阵的运算。第一次接触到一个纯粹的数学方法能够应用在解决实际问题上，颇感惊奇，所以尝试了研究和实现。</p>
							<p>论文的题目为Deformation Transfer for Triangle Meshes，作者为Robert W. Sumner和 Jovan Popovi´c。2004年入选SIGGRAPH的一篇论文。算法的输入给定三个文件s0.obj、s1.obj和t0.obj，描述了三个个由大量三角网格组成的人物面部模型。其中s0和s1是同一个人物的面部不同表情，该算法需要将s0到s1的转换应用到t0上，得到相似变换的t1文件。</p>
							<p>V代表点，后面接三个代表该点的空间xyz坐标值，f代表小三角面片，后面接三个点的序号。</p>
							<p>s0到s1是同一个人的平静和惊讶的表情，目标是将这样的惊讶应用到t0表情上，得到t0的惊讶表情。每一个面片都涉及大量的数据，由此形成的矩阵是巨大的，利用编程语言进行计算的时候需要花费大量的时间和内存空间。这个算法最吸引人的地方在于，它可以将一个动作应用在许多不同的模型上，可以省略大量重复的工作。并且，在算法中，动作的变换是由纯数学方法（矩阵）描述的，因此一个动作的变换可以抽象出一个矩阵，这一个矩阵又可以应用在不同的模型上，得到不同的结果。</p>
							<p>前面说到，一个面部模型由大量的三角面片组成，因此每个三角面片的点数越多，模型越细腻，而且点数和面数有数量上的关系，即面数约等于点数的两倍。简单证明如下，一个三角形每个角平均是60度，一个点周围一圈共360度，所以一个点周围平均可以有6个面。意思是同一个点由6个面共享，而一个三角形有3个点，那么每个面片平均可以得到3/6个点，即半个点。所以三角面片的数量约等于点的数量的2倍。</p>
							<p>下面给出实现的代码。</p>
							<pre># -*- coding:utf-8 -*-
	import numpy as np
	import time as tm
	
	start = tm.clock()
	
	
	def get_v4(v1, v2, v3):
	    '''
	    传入3个点list类型，输出v4，list类型
	    '''
	    a = []
	    b = []
	    v4 = []  # 各列表之间不能用逗号，要用分号
	    for i in range(3):
	        a.append(v2[i] - v1[i])
	        b.append(v3[i] - v1[i])
	    multiple = [a[1] * b[2] - a[2] * b[1], a[2] * b[0] - a[0] * b[2], a[0] * b[1] - a[1] * b[0]]
	    mo = np.sqrt(multiple[0] ** 2 + multiple[1] ** 2 + multiple[2] ** 2)
	    for i in range(3):
	        multiple[i] /= mo
	    for i in range(3):
	        v4.append(v1[i] + multiple[i])
	    return v4
	
	
	def get_point_list(filename):
	    f = open(filename)
	    lines = f.readlines()
	    f.close()
	    point_list = []
	    v = []
	    s = ""
	    for line in lines:  # 读出s0文件中的每个点坐标，组装成 point_list_s0
	        for char in line:
	            if char != ' ':
	                s += char
	            else:
	                num = float(s)
	                v.append(num)
	                s = ""
	        num = float(s)
	        v.append(num)
	        s = ''
	        point_list.append(v)
	        v = []
	    return point_list
	
	
	point_list_s0 = get_point_list('s0_v.obj')
	point_list_s1 = get_point_list('s1_v.obj')
	point_list_t0 = get_point_list('t0_v.obj')
	
	s = ""
	
	face = open("face.obj")
	face_lines = face.readlines()
	face.close()
	w_x = np.array([])
	w_y = w_x
	w_z = w_x
	for line in face_lines:
	    number = []
	    for char in line:
	        if (char == ' ') | (char == '\n'):
	            number.append(int(s))
	            s = ""
	        else:
	            s += char
	    v1, _v1, t0_v1 = point_list_s0[number[0] - 1], point_list_s1[number[0] - 1], point_list_t0[number[0] - 1]
	    v1_array, _v1_array, t0_v1_array = np.array(v1), np.array(_v1), np.array(t0_v1)
	    v2, _v2, t0_v2 = point_list_s0[number[1] - 1], point_list_s1[number[1] - 1], point_list_t0[number[1] - 1]
	    v2_array, _v2_array, t0_v2_array = np.array(v2), np.array(_v2), np.array(t0_v2)
	    v3, _v3, t0_v3 = point_list_s0[number[2] - 1], point_list_s1[number[2] - 1], point_list_t0[number[2] - 1]
	    v3_array, _v3_array, t0_v3_array = np.array(v3), np.array(_v3), np.array(t0_v3)
	    v4, _v4, t0_v4 = get_v4(v1, v2, v3), get_v4(_v1, _v2, _v3), get_v4(t0_v1, t0_v2, t0_v3)
	    v4_array, _v4_array, t0_v4_array = np.array(v4), np.array(_v4), np.array(t0_v4)
	
	    V = np.matrix([v2_array - v1_array, v3_array - v1_array, v4_array - v1_array]).T
	    _V = np.matrix([_v2_array - _v1_array, _v3_array - _v1_array, _v4_array - _v1_array]).T
	    t0_V = np.matrix([t0_v2_array - t0_v1_array, t0_v3_array - t0_v1_array, t0_v4_array - t0_v1_array]).T
	    S = _V * V.I  # 得到S，matrix类型
	    # w.append(((S*t0_V).T).getA1())
	    tmp = (S * t0_V).T
	    w_x = np.append(w_x, tmp[:, 0])  # w此时是array类型
	    w_y = np.append(w_y, tmp[:, 1])
	    w_z = np.append(w_z, tmp[:, 2])
	
	del point_list_s0, point_list_s1, point_list_t0, face_lines
	
	VNUM = 1069  # 点的个数
	FNUM = 1947  # 面的个数
	col_num = VNUM + FNUM  # get_A模块，得到稀疏矩阵
	row_num = 3 * FNUM
	A = np.array([[0] * col_num] * row_num)  # A此时是array类型
	n = VNUM  # 点数
	face = open("face.obj")
	face_lines = face.readlines()
	face.close()
	f = 1  # 第f个面，对读入的三角面计数
	for line in face_lines:
	    s = ""
	    number = []  # 每个三角形三个点的序号
	    for char in line:
	        if (char == ' ') | ('\n' == char):
	            number.append(int(s))
	            s = ""
	        else:
	            s += char
	    for count in range(3):
	        A[3 * (f - 1) + count][number[0] - 1] = -1
	        if count < 2:
	            A[3 * (f - 1) + count][number[count + 1] - 1] = 1
	        else:
	            A[3 * (f - 1) + count][n + f - 1] = 1
	    f += 1
	
	A_I = np.matrix(A).I  # 将A转换成matrix类型
	w_x = np.matrix(w_x).T  # 将w_x转换成matrix类型
	w_y = np.matrix(w_y).T  #
	w_z = np.matrix(w_z).T  #
	xx = A_I * w_x
	yy = A_I * w_y
	zz = A_I * w_z
	x_arr = np.array(xx)
	y_arr = np.array(yy)
	z_arr = np.array(zz)
	fp = open("obj.obj", "w")
	for r in range(VNUM):
	    fp.write('v ')
	    s = str(x_arr[r])
	    fp.write(s[1:len(s) - 1])
	    fp.write(' ')
	    s = str(y_arr[r])
	    fp.write(s[1:len(s) - 1])
	    fp.write(' ')
	    s = str(z_arr[r])
	    fp.write(s[1:len(s) - 1])
	    fp.write('\n')
	for line in face_lines:
	    fp.write('f ')
	    fp.write(str(line))
	
	fp.close()
	end = tm.clock()
	print "Cost %s seconds" % (end - start)
	</pre>
						</div>
						<div class="text">
							<img style="margin: 0 auto;display: block;width: 10%;" src="img/zeppelin.png" />
							<h1>About Apache Zeppelin</h1>
							<h2>OVERVIEW</h2>
							<p>A completely open web-based notebook that enables interactive data analytics.</p>
							<p>Apache Zeppelin is a new and incubating multi-purposed web-based notebook which brings data ingestion, data exploration, visualization, sharing and collaboration features to Hadoop and Spark.</p>
							<h2>WHAT ZEPPELIN DOES</h2>
							<p>Interactive browser-based notebooks enable data engineers, data analysts and data scientists to be more productive by developing, organizing, executing, and sharing data code and visualizing results without referring to the command line or needing the cluster details. Notebooks allow these users not only allow to execute but to interactively work with long workflows.  There are a number of notebooks available with Spark. iPython remains a mature choice and great example of a data science notebook.  The Hortonworks Gallery provides an Ambari stack definition to help our customers quickly set up iPython on their Hadoop clusters.</p>
							<p>Apache Zeppelin is a new and upcoming web-based notebook which brings data exploration, visualization, sharing and collaboration features to Spark.   It support Python, but also a growing list of programming languages such as Scala, Hive, SparkSQL, shell and markdown. </p>
						</div>
						<div class="text">
							<h1>Zeppelin的搭建</h1>
							<h2>环境准备</h2>
							<p>先搭建好hadoop和spark环境，在此不再赘述。</p>
							<p>安装scala和jdk，将两个软件包上传至/usr/local，各自解压后在profile里面设置环境变量，HADOOP_HOME、HADOOP_CONF_DIR、YARN_CONF_DIR、SPARK_HOME、JAVA_HOME、CLASSPATH、SCALA_HOME、PATH等。注意路径不要写错，完成后source一下。</p>
							<p>shell输入命令检查各个软件包是否正确安装。</p>
							<h2>zeppelin安装</h2>
							<p>创建zeppelin用户，useradd -m zeppelin</p>
							<p>下载官网的全解释器二进制包700+MB。上传至/home/zeppelin/目录下，开始zeppelin的配置工作。将conf中的zeppelin-env.sh.template与zeppelin-site.xml.template复制一份，去掉template，修改zeppelin-env.sh，增加几行：</p>
							<pre>
	export SPARK_MASTER_IP=127.0.0.1
	
	export SPARK_LOCAL_IP=127.0.0.1
	
	export SPARK_HOME=/usr/local/spark2
	
	export ZEPPELIN_MEM="-Xmx2048m -XX:PermSize=256M"</pre>
							<p>若8080端口已经被占用，则修改zeppelin-site.xml配置文件，<name>zeppelin.server.port</name>设置其value为9995。
	
	lib/下的包jackson-databind/jackson-annonations/jackson-core三个jar包全替换成2.6.5版本的。jackson jar包下载链接 
	
	以zeppelin用户身份在bin/目录下执行./zeppelin-daemon.sh start。浏览器中输入"ip":"port"就可以看见了。</p>
	
						</div>
						<div class="text">
							<h1>Zeppelin常见问题</h1>
							<p>如果出现Zeppelin running but process is dead，检查conf路径下是否存在zeppelin-site.xml配置文件。</p>
							<p>notebook与spark交互找文件时可能会出现jackson版本问题带来的错误：<br/>
	com.fasterxml.jackson..databind.JsonMappingException:Could not found<br/>
	这时需要在$ZEPPELIN_HOME/lib下把jackson-annotations*.jar  jackson-databind*.jar  jackson-core*.jar换成2.4.4版本。可以在livy/jars或者spark安装路径下找到。</p>
							<p>如果用户名密码正确却不能登录，可能是因为zeppelin-daemon没有启动。用zeppelin身份执行./zeppelin-daemon.sh restart</p>
							<p>运行zeppelin 时遇到问题：<br/>
	1. java.lang.NoSuchMethodError: org.apache.hadoop.tracing.SpanReceiverHost.get(Lorg/apache/hadoop/conf/</p>
							<p>解决方法：<br/>
	cd zeppelin-0.6.2-bin-all/lib<br/>
	rm hadoop-annotations-×××.jar<br />
	rm hadoop-auth-×××.jar<br />
	rm hadoop-common-×××.jar<br /><br />
	
	cp spark/jars/hadoop-annotations-×××.jar ./<br />
	cp spark/jars/hadoop-auth-×××.jar ./<br />
	cp spark/jars/hadoop-common-×××.jar ./<br />
	</p>
							<p>重启zeppelin 又出现下面问题：<br />
	2.  Spark Error: Could not initialize class org.apache.spark.rdd.RDDOperationScope<br />
	解决方法：<br />
	cd zeppelin-0.6.2-bin-all/lib<br />
	rm jackson-annotations-×××.jar<br />
	rm jackson-core-×××.jar<br />
	rm jackson-databind-×××.jar<br /><br />
	
	cp spark/jars/jackson-databind-×××.jar ./<br />
	cp spark/jars/jackson-core-×××.jar ./<br />
	cp spark/jars/jackson-annotations-×××.jar ./<br /><br />
	
	再重启zeppelin 解决问题，删完拷完后一定要重启zeppelin<br />
	</p>
							<p>3.将jdbc连接数据库时遇到<br />zeppelin java.lang.ClassNotFoundException: com.mysql.jdbc.Driver<br />
	因为$ZEPPELIN_HOME/lib目录下缺少mysql-connector-java.jar，在其他位置找到它并把它加到$ZEPPELIN_HOME/lib目录下，修改属主和权限。
	</p>
							<p>4.spark-shell出现ConnectException可能是hadoop、spark没有启动。
	</p>
						</div>
						<div class="text">
							<h1>Python编码问题</h1>
							<p>字符串是Python中最常用的数据类型，而且很多时候你会用到一些不属于标准ASCII字符集的字符，这时候代码就很可能抛出UnicodeDecodeError: ‘ascii’ codec can’t decode byte 0xc4 in position 10: ordinal not in range(128)异常。这种异常在Python中很容易遇到，尤其是在Python2.x中，是一个很让初学者费解头疼的问题。不过，如果你理解了Python的Unicode，并在编码中遵循一定的原则，这种编码问题还是比较容易理解和解决的。</p>
							<p>字符串在Python内部的表示是unicode编码，因此，在做编码转换时，通常需要以unicode作为中间编码，即先将其他编码的字符串解码（decode）成unicode，再从unicode编码（encode）成另一种编码。但是，Python 2.x的默认编码格式是ASCII，就是说，在没有指定Python源码编码格式的情况下，源码中的所有字符都会被默认为ASCII码。也因为这个根本原因，在Python 2.x中经常会遇到UnicodeDecodeError或者UnicodeEncodeError的异常。</p>
							<h2>关于Unicode</h2>
							<p>Unicode是一种字符集，它为每一种现代或古代使用的文字系统中出现的每一个字符都提供了统一的序列号，规定了符号的二进制代码，但没有规定这个二进制代码应该如何存储。也就是说：Unicode的编码方式是固定的，但是实现方式根据不同的需要有跟多种，常见的有UTF-8、UTF-16和UTF-32等。更多的介绍大家可以参看维基百科：Unicode</p>
							<p>为了能够处理Unicode数据，同时兼容Python某些内部模块，Python 2.x中提供了Unicode这种数据类型，通过decode和encode方法可以将其它编码和Unicode编码相互转化，但同时也引入了UnicodeDecodeError和UnicodeEncodeError异常。</p>
							<p>在Python2.x中，字符串str解码decode()为Unicode，反过来，Unicode编码encode()为str。</p>
							<p>在Python3.x中，字符串str以Unicode编码，可以encode为各种编码的字符串。</p>
						</div>
						<div class="text">
							<p>This is 6th paragraph.</p>
						</div>
						<div class="text">
							<p>This is 7th paragraph.</p>
						</div>
						<div class="text">
							<p>This is 8th paragraph.</p>
						</div>
						<div class="text">
							<p>This is 9th paragraph.</p>
						</div>
					</div>
				</div>
			</div>
		</div>
		<script type="text/javascript">
			$(function(){
				$('.time').text((new Date()).toLocaleString());
				setInterval(function() {
				    var time = (new Date()).toLocaleString();
				    $('.time').text(time);
				}, 1000);
				$('.figure').mousedown(function(){
					var idx = $(this).index();
					$('.grid-wrap').hide('slow');
					$('.text').eq(idx).show('slow', function(){
						$('.close-content').show('fast');
					});
				});
				$('.close-content').mousedown(function(){
					$('.grid-wrap').show('slow');
					$(".text").hide('slow', function(){
						$('.close-content').hide('fast');
					})
				});
				$('.wallpaper').mousedown(function(){
					var height = $(window).height();
					$(this).slideUp();
					$('.time').animate({'bottom':height});
				});
				$('.down').mousedown(function(){
					$('.wallpaper').slideDown();
					$('.time').animate({'bottom':'0px'});
				});
				$('.up').mousedown(function(){
					$('html').animate({scrollTop: 0}, 500);
				});

			});
		</script>
	</body>
</html>
